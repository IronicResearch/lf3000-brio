// TestResourceNonBlocking.h

#include <cxxtest/TestSuite.h>
#include <boost/shared_array.hpp>
#include <ResourceMPI.h>
#include <DebugMPI.h>
#include <EventMessage.h>
#include <SystemErrors.h>
#include <SystemEvents.h>
#include <EventListener.h>
#include <EventMPI.h>
#include <UnitTestUtils.h>

LF_USING_BRIO_NAMESPACE()

//============================================================================
// MyRsrcEventListener
//============================================================================
CURI	gPkg_all = "LF/Brio/UnitTest";
CURI	gPkg_A = "LF/Brio/UnitTest/A";
CURI	gPkg_B = "LF/Brio/UnitTest/B";
CURI	gPkg_C = "LF/Brio/UnitTest/C";
/*
template <typename T, typename D>
class scoped_resource
{
private:
	boost::shared_ptr<void> rsrc_;

public:
	explicit scoped_resource(T rsrc)
	{
		rsrc_ = boost::shared_ptr<T>(rsrc, D(mpi));
	}

    operator T() const { return static_cast<T>rsrc_.get(); }
};

struct RsrcHndlDeleter
{
	explicit RsrcHndlDeleter(CResourceMPI& mpi) : mpi_(mpi) {}
 	void operator()(void * p) { mpi_.UnloadRsrc(static_cast<T>(p)) }
 private:
 	CResourceMPI&	mpi_;
};

typedef scoped_resource<tRsrcHndl, RsrcHndlDeleter> RsrcHndl;

RsrcHndl rsrc(mpi.LoadRsrc(hndl), mpi);
*/

const tEventType kMyHandledTypes[] = { kAllResourceEvents };						
//----------------------------------------------------------------------------
class MyRsrcEventListener : public IEventListener
{

public:
	MyRsrcEventListener( ) 
		: IEventListener(kMyHandledTypes, ArrayCount(kMyHandledTypes))
	{		
	}
	
	virtual tEventStatus Notify( const IEventMessage& msg )
	{
		U16 size		= msg.GetSizeInBytes();
		msg_			= boost::shared_array<U8>(new U8[size]);
		memcpy(msg_.get(), &msg, size);
		return kEventStatusOKConsumed;
	}
	
	const IEventMessage* GetEventMsg() const
	{
		return reinterpret_cast<const IEventMessage*>(msg_.get());
	}
	
	void Reset()
	{
		msg_.reset();
	}
	
private:
	boost::shared_array<U8>	msg_;
};



//============================================================================
// TestRsrcMgr functions
//============================================================================
class TestRsrcNonBlocking : public CxxTest::TestSuite, TestSuiteBase
{
private:
	CResourceMPI*		rsrcmgr_;
	MyRsrcEventListener	handler_;
public:
	//------------------------------------------------------------------------
	void setUp( )
	{
		rsrcmgr_ = new CResourceMPI(kNonBlocking, &handler_);
	}

	//------------------------------------------------------------------------
	void tearDown( )
	{
		rsrcmgr_->CloseAllDevices();
		delete rsrcmgr_; 
	}
	
	//------------------------------------------------------------------------
	void resetHandler( MyRsrcEventListener& handler )
	{
		handler.Reset();
	}

	//------------------------------------------------------------------------
	bool handlerIsReset( MyRsrcEventListener& handler )
	{
		return handler.GetEventMsg() == NULL;
	}

	//------------------------------------------------------------------------
	void testWasCreated( )
	{
		TS_ASSERT( rsrcmgr_ != NULL );
		TS_ASSERT( rsrcmgr_->IsValid() == true );
	}
	
	//------------------------------------------------------------------------
	void testFailsWhenBlockingAndListenerSpecified( )
	{
		TS_ASSERT_THROWS( CResourceMPI(kBlocking, &handler_), UnitTestAssertException );
	}
	
	//------------------------------------------------------------------------
	void testCoreMPI( )
	{
		tVersion		version;
		const CString*	pName;
		const CURI*		pURI;
		
		pName = rsrcmgr_->GetMPIName();
		TS_ASSERT_EQUALS( *pName, "ResourceMPI" );
		version = rsrcmgr_->GetModuleVersion();
		TS_ASSERT_EQUALS( version, 2 );
		pName = rsrcmgr_->GetModuleName();
		TS_ASSERT_EQUALS( *pName, "Resource" );
		pURI = rsrcmgr_->GetModuleOrigin();
		TS_ASSERT_EQUALS( *pURI, "/LF/System/Resource" );
	}
	
	//------------------------------------------------------------------------
	void testOpenCloseAllDevices( )
	{
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenAllDevices() );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceAllDevicesOpenedEvent, handler_.GetEventMsg()->GetEventType() );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->CloseAllDevices() );

		resetHandler(handler_);
		MyRsrcEventListener	overrideHandler;
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT( handlerIsReset(overrideHandler) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenAllDevices(kNoOptionFlags, &overrideHandler) );
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT( !handlerIsReset(overrideHandler) );
		
		TS_ASSERT_EQUALS( kResourceAllDevicesOpenedEvent, overrideHandler.GetEventMsg()->GetEventType() );
		resetHandler(overrideHandler);
		TS_ASSERT( handlerIsReset(overrideHandler) );
	}

	//------------------------------------------------------------------------
	void testOpenCloseSingleDevices()
	{
		//TODO: Implement on future (non-Lightning) platform
	}

	//------------------------------------------------------------------------
	void testFindPackage()
	{
		//TODO: Test events on package openings
	}

	// FIXME/tp: Test what happens when devices/pkgs/resources are not explicitly freed but CResourceMPI goes out of scope.
	// FIXME/tp: Work through correct smart handles for devices/pkgs/resources.
		
	//------------------------------------------------------------------------
	void testMissingRsrc( )
	{
		tRsrcHndl		handle;
		ConstPtrCString	pStr;
		ConstPtrCURI	pURI;
		tRsrcType		type;
		tVersion		version;
		U32				size;
		tPtr			ptr;
		
		resetHandler(handler_);
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenAllDevices() );
		TS_ASSERT( !handlerIsReset(handler_) );
		resetHandler(handler_);
		TS_ASSERT( handlerIsReset(handler_) );
		tPackageHndl pkg = rsrcmgr_->FindPackage("CountTest", &gPkg_A);
		TS_ASSERT_DIFFERS( kInvalidPackageHndl, pkg );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenPackage(pkg) );

		handle = rsrcmgr_->FindRsrc("bogus_resource_name");
		TS_ASSERT_EQUALS( kInvalidRsrcHndl, handle );
		// The following calls assert when provided an invalid handle
		TS_ASSERT_THROWS( rsrcmgr_->GetURI(handle), UnitTestAssertException );
		TS_ASSERT_THROWS( rsrcmgr_->GetVersion(handle), UnitTestAssertException );
		TS_ASSERT_THROWS( rsrcmgr_->GetVersionStr(handle), UnitTestAssertException );
		TS_ASSERT_THROWS( rsrcmgr_->GetPackedSize(handle), UnitTestAssertException );
		TS_ASSERT_THROWS( rsrcmgr_->GetUnpackedSize(handle), UnitTestAssertException );
		TS_ASSERT_THROWS( rsrcmgr_->GetPtr(handle), UnitTestAssertException );
		TS_ASSERT( handlerIsReset(handler_) );
	}

	//------------------------------------------------------------------------
	void testFindAndLoadTextRsrc( )
	{
		tRsrcHndl		handle;
		ConstPtrCString	pStr;
		ConstPtrCURI	pURI;
		tRsrcType		type;
		tVersion		version;
		U32				size;
		tPtr			ptr = (void*) 1;
		TS_ASSERT( handlerIsReset(handler_) );
		const U32		kSizeHelloWorldText	= 17;
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenAllDevices() );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceAllDevicesOpenedEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		tPackageHndl pkg = rsrcmgr_->FindPackage("LoadTest", &gPkg_B);
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenPackage(pkg) );
		handle = rsrcmgr_->FindRsrc("one");
		TS_ASSERT_DIFFERS( kInvalidRsrcHndl, handle );
		pURI = rsrcmgr_->GetURI(handle);
		TS_ASSERT_EQUALS( "LF/Brio/UnitTest/B.one", *pURI );
//		type = rsrcmgr_->GetType(handle);
//		TS_ASSERT_EQUALS( type, kTextFile );
		TS_ASSERT_EQUALS( 1, rsrcmgr_->GetVersion(handle) );
		const CString*	pVer;
		pVer = rsrcmgr_->GetVersionStr(handle);
		TS_ASSERT_EQUALS( *pVer, "1" );
		TS_ASSERT_EQUALS( kSizeHelloWorldText, rsrcmgr_->GetPackedSize(handle) );
		TS_ASSERT_EQUALS( kSizeHelloWorldText, rsrcmgr_->GetUnpackedSize(handle) );
		
		// not loaded yet test
		TS_ASSERT_THROWS( rsrcmgr_->GetPtr(handle), UnitTestAssertException );
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->LoadRsrc(handle) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceLoadedEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		ptr = rsrcmgr_->GetPtr(handle);
		CString	helloWorld = reinterpret_cast<char*>(ptr);
		TS_ASSERT_EQUALS( helloWorld, "Hello World Text" );
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->UnloadRsrc(handle) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceUnloadedEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		TS_ASSERT_THROWS( rsrcmgr_->GetPtr(handle), UnitTestAssertException );
	}

	//------------------------------------------------------------------------
	void testFindAndOpenBinaryRsrc( )
	{
		tRsrcHndl		handle;
		ConstPtrCString	pStr;
		ConstPtrCURI	pURI;
		tRsrcType		type;
		tVersion		version;
		U32				size;
		tPtr			ptr = (void*) 1;
		const U32		kBellAudioSize	= 3000;
		const U32		kBufSize	= 80;
		U8 				buffer[kBufSize];
		
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenAllDevices() );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceAllDevicesOpenedEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		tPackageHndl pkg = rsrcmgr_->FindPackage("LoadTest", &gPkg_B);
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenPackage(pkg) );
		handle = rsrcmgr_->FindRsrc("five");
		TS_ASSERT_DIFFERS( kInvalidRsrcHndl, handle );
		pURI = rsrcmgr_->GetURI(handle);
		TS_ASSERT_EQUALS( "LF/Brio/UnitTest/B/five", *pURI );
//		type = rsrcmgr_->GetType(handle);
//		TS_ASSERT_EQUALS( type, kTextFile );
		TS_ASSERT_EQUALS( 5, rsrcmgr_->GetVersion(handle) );
		const CString*	pVer;
		pVer = rsrcmgr_->GetVersionStr(handle);
		TS_ASSERT_EQUALS( *pVer, "255" );
		TS_ASSERT_EQUALS( kBellAudioSize, rsrcmgr_->GetPackedSize(handle) );
		TS_ASSERT_EQUALS( kBellAudioSize * 2, rsrcmgr_->GetUnpackedSize(handle) );
		
		// not loaded test
		TS_ASSERT_THROWS( rsrcmgr_->GetPtr(handle), UnitTestAssertException );
		TS_ASSERT_EQUALS( kResourceNotOpenErr, rsrcmgr_->ReadRsrc(handle, buffer, kBufSize) );
		// FIXME/tp: Hmmm, kinda inconsistent to assert in only one place
		
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenRsrc(handle, kOpenRsrcOptionRead) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceOpenedEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		TS_ASSERT_THROWS( rsrcmgr_->GetPtr(handle), UnitTestAssertException );
	
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->ReadRsrc(handle, buffer, kBufSize) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceReadDoneEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		for(unsigned int i=0; i < kBufSize; ++i)
		{
			// Report only a single failure in the buffer mismatch
			if(buffer[i] != i)
			{
				TS_ASSERT_EQUALS( buffer[i], i );
				break;
			}
		}
		
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->CloseRsrc(handle) );
	}
	
	void xtestFindOpenAndWriteBinaryRsrc( )
	{
		// FIXME/tp: Reenable after 6/15 delivery
		tRsrcHndl		handle;
		U32				size;
		const U32		kBufSize	= 80;
		U8 				buffer[kBufSize];
		U8 				buffer_inv[kBufSize];
		U8 				buffer_inv_test[kBufSize];
		
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenAllDevices() );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceAllDevicesOpenedEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		rsrcmgr_->SetDefaultURIPath("/home/lfu/workspace/Brio2/apprsrc/Applic2");
		handle = rsrcmgr_->FindRsrc("app5.bin");
		TS_ASSERT_DIFFERS( kInvalidRsrcHndl, handle );
		
		TS_ASSERT( handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->OpenRsrc(handle,
			(kOpenRsrcOptionRead | kOpenRsrcOptionWrite) ) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceOpenedEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);

		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->ReadRsrc(handle, buffer, kBufSize) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceReadDoneEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		for(unsigned int i=0; i < kBufSize; ++i)
		{
			// Report only a single failure in the buffer mismatch
			if(buffer[i] != i)
			{
				TS_ASSERT_EQUALS( buffer[i], i );
				break;
			}
		}
		// seek forward from current position (80 from current, or 160 from start)
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->SeekRsrc(handle, kBufSize, kSeekRsrcOptionCur) );
		// write inverted data to the buffer
		for(unsigned int i=0; i < kBufSize; ++i)
		{
			buffer_inv[i] = ~(i + 160);
		}
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->WriteRsrc(handle, buffer_inv, kBufSize, &size) );
		TS_ASSERT_EQUALS( kBufSize, size );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceWriteDoneEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		// seek back to the start of the file
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->SeekRsrc(handle, 0, kSeekRsrcOptionSet) );
		// read/verify normal data (check for no overwrite)
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->ReadRsrc(handle, buffer, kBufSize) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceReadDoneEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		for(unsigned int i=0; i < kBufSize; ++i)
		{
			// Report only a single failure in the buffer mismatch
			if(buffer[i] != i)
			{
				TS_ASSERT_EQUALS( buffer[i], i );
				break;
			}
		}
		// seek to modified region (SET)
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->SeekRsrc(handle, kBufSize*2, kSeekRsrcOptionSet) );
		// read/verify inverted data
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->ReadRsrc(handle, buffer_inv_test, kBufSize) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceReadDoneEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		for(unsigned int i=0; i < kBufSize; ++i)
		{
			// Report only a single failure in the buffer mismatch
			if(buffer_inv_test[i] != buffer_inv[i])
			{
				TS_ASSERT_EQUALS( buffer_inv_test[i], buffer_inv[i] );
				break;
			}
		}
		// seek back to modified region (SET)
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->SeekRsrc(handle, kBufSize*2, kSeekRsrcOptionSet) );
		// write original data to the file
		for(unsigned int i=0; i < kBufSize; ++i)
		{
			buffer_inv[i] = i + 160;
		}
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->WriteRsrc(handle, buffer_inv, kBufSize, &size) );
		TS_ASSERT_EQUALS( kBufSize, size );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceWriteDoneEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		// seek back to the start of the file
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->SeekRsrc(handle, 0) );
		// read/verify the original data
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->ReadRsrc(handle, buffer, kBufSize) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceReadDoneEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		for(unsigned int i=0; i < kBufSize; ++i)
		{
			// Report only a single failure in the buffer mismatch
			if(buffer[i] != i)
			{
				TS_ASSERT_EQUALS( buffer[i], i );
				break;
			}
		}
		// seek to the restored region of the file (CUR)
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->SeekRsrc(handle, kBufSize, kSeekRsrcOptionCur) );
		// read/verify the restored data
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->ReadRsrc(handle, buffer_inv_test, kBufSize) );
		TS_ASSERT( !handlerIsReset(handler_) );
		TS_ASSERT_EQUALS( kResourceReadDoneEvent, handler_.GetEventMsg()->GetEventType() );
		resetHandler(handler_);
		for(unsigned int i=0; i < kBufSize; ++i)
		{
			// Report only a single failure in the buffer mismatch
			if(buffer_inv_test[i] != buffer_inv[i])
			{
				TS_ASSERT_EQUALS( buffer_inv_test[i], buffer_inv[i] );
				break;
			}
		}
		
		TS_ASSERT_EQUALS( kNoErr, rsrcmgr_->CloseRsrc(handle) );
	}

	//------------------------------------------------------------------------
	void testFindAndLoadTextRsrcOverloadListener( )
	{
		// TODO: Make Load/UnloadRsrc calls with explicit listener parameter
		// and make sure appropriate listeners get called
	}
		
	//------------------------------------------------------------------------
	void testFindAndOpenBinaryRsrcOverloadListener( )
	{
		// TODO: Make Open/Close/ReadRsrc calls with explicit listener parameter
		// and make sure appropriate listeners get called
	}
	
};

// Totest: packages containing packages
// packages containing resources with URIs with alternate bases

